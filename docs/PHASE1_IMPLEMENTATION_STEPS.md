# Phase 1å®Ÿè£…æ‰‹é †æ›¸

ã“ã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã§ã¯ã€Phase 1ã®å®Ÿè£…ã‚’é †ã‚’è¿½ã£ã¦èª¬æ˜ã—ã¾ã™ã€‚å„ã‚¹ãƒ†ãƒƒãƒ—ã‚’å®Œäº†ã•ã›ã‚‹ã“ã¨ã§ã€åŸºæœ¬çš„ãªCRUDæ©Ÿèƒ½ãŒå®Œå…¨ã«å‹•ä½œã™ã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã™ã€‚

## ç›®æ¬¡

- [Phase 1ã®æ¦‚è¦](#phase-1ã®æ¦‚è¦)
- [å‰ææ¡ä»¶](#å‰ææ¡ä»¶)
- [å®Ÿè£…ã‚¹ãƒ†ãƒƒãƒ—](#å®Ÿè£…ã‚¹ãƒ†ãƒƒãƒ—)
  - [Step 1: ã‚¹ã‚­ãƒ¼ãƒç§»è¡Œ](#step-1-ã‚¹ã‚­ãƒ¼ãƒç§»è¡Œ)
  - [Step 2: ãƒ¢ãƒ‡ãƒ«å±¤ã®æ›´æ–°](#step-2-ãƒ¢ãƒ‡ãƒ«å±¤ã®æ›´æ–°)
  - [Step 3: ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£é–¢æ•°ã®å®Ÿè£…](#step-3-ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£é–¢æ•°ã®å®Ÿè£…)
  - [Step 4: ãƒªãƒã‚¸ãƒˆãƒªå±¤ã®å®Œå…¨å®Ÿè£…](#step-4-ãƒªãƒã‚¸ãƒˆãƒªå±¤ã®å®Œå…¨å®Ÿè£…)
  - [Step 5: ã‚µãƒ¼ãƒ“ã‚¹å±¤ã®å®Œå…¨å®Ÿè£…](#step-5-ã‚µãƒ¼ãƒ“ã‚¹å±¤ã®å®Œå…¨å®Ÿè£…)
  - [Step 6: ãƒãƒ³ãƒ‰ãƒ©ãƒ¼å±¤ã®å®Œå…¨å®Ÿè£…](#step-6-ãƒãƒ³ãƒ‰ãƒ©ãƒ¼å±¤ã®å®Œå…¨å®Ÿè£…)
  - [Step 7: ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ãƒ†ã‚¹ãƒˆã®å®Ÿè£…](#step-7-ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ãƒ†ã‚¹ãƒˆã®å®Ÿè£…)
  - [Step 8: ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰ã®æ›´æ–°](#step-8-ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰ã®æ›´æ–°)
  - [Step 9: çµ±åˆãƒ†ã‚¹ãƒˆ](#step-9-çµ±åˆãƒ†ã‚¹ãƒˆ)
- [å®Œäº†ãƒã‚§ãƒƒã‚¯ãƒªã‚¹ãƒˆ](#å®Œäº†ãƒã‚§ãƒƒã‚¯ãƒªã‚¹ãƒˆ)

---

## Phase 1ã®æ¦‚è¦

**ç›®æ¨™:**
- ãƒ¦ãƒ¼ã‚¶ãƒ¼CRUDæ©Ÿèƒ½ã®å®Œå…¨å®Ÿè£…
- è¨­è¨ˆä»•æ§˜ã«å®Œå…¨æº–æ‹ ã—ãŸã‚¹ã‚­ãƒ¼ãƒ
- ãƒšãƒ¼ã‚¸ãƒãƒ¼ã‚·ãƒ§ãƒ³å®Ÿè£…
- çµ±ä¸€ã•ã‚ŒãŸã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°
- ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³å®Ÿè£…
- å˜ä½“ãƒ†ã‚¹ãƒˆã®ã‚«ãƒãƒ¬ãƒƒã‚¸70%ä»¥ä¸Š

**æ‰€è¦æ™‚é–“:** 1-2é€±é–“

**æˆæœç‰©:**
- å‹•ä½œã™ã‚‹åŸºæœ¬CRUD API
- ãƒ†ã‚¹ãƒˆã‚³ãƒ¼ãƒ‰
- æ›´æ–°ã•ã‚ŒãŸãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰
- ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ

---

## å‰ææ¡ä»¶

ä»¥ä¸‹ãŒå®Œäº†ã—ã¦ã„ã‚‹ã“ã¨ã‚’ç¢ºèªã—ã¦ãã ã•ã„:

- [ ] **[QUICK_START.md](QUICK_START.md)** ã«å¾“ã£ã¦é–‹ç™ºç’°å¢ƒã‚’ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—æ¸ˆã¿
- [ ] `make dev` ã§é–‹ç™ºç’°å¢ƒãŒèµ·å‹•ã™ã‚‹
- [ ] Phase 0ã®ã‚³ãƒ¼ãƒ‰ãŒå‹•ä½œã—ã¦ã„ã‚‹
- [ ] Gitä½œæ¥­ãƒ–ãƒ©ãƒ³ãƒã‚’ä½œæˆæ¸ˆã¿ï¼ˆä¾‹: `feature/phase1-implementation`ï¼‰

```bash
# ä½œæ¥­ãƒ–ãƒ©ãƒ³ãƒã‚’ä½œæˆ
git checkout main
git pull origin main
git checkout -b feature/phase1-implementation
```

---

## å®Ÿè£…ã‚¹ãƒ†ãƒƒãƒ—

### Step 1: ã‚¹ã‚­ãƒ¼ãƒç§»è¡Œ

**ç›®çš„:** Phase 0ã®ç°¡ç•¥åŒ–ã‚¹ã‚­ãƒ¼ãƒã‚’è¨­è¨ˆä»•æ§˜ã«æº–æ‹ ã—ãŸã‚¹ã‚­ãƒ¼ãƒã«ç§»è¡Œã™ã‚‹

**è©³ç´°:** [MIGRATION_FROM_PHASE0.md](MIGRATION_FROM_PHASE0.md) ã‚’å‚ç…§

#### 1-1. ãƒã‚¤ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ãƒ•ã‚¡ã‚¤ãƒ«ã®ä½œæˆ

```bash
# ãƒã‚¤ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ä½œæˆ
touch backend/migrations/000002_update_users_table.up.sql
touch backend/migrations/000002_update_users_table.down.sql
```

**ãƒ•ã‚¡ã‚¤ãƒ«: `backend/migrations/000002_update_users_table.up.sql`**

```sql
-- æ–°ã—ã„ã‚«ãƒ©ãƒ ã‚’è¿½åŠ 
ALTER TABLE users ADD COLUMN full_name VARCHAR(100);
ALTER TABLE users ADD COLUMN department VARCHAR(100);
ALTER TABLE users ADD COLUMN last_login TIMESTAMP;

-- ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã‚«ãƒ©ãƒ ã‚’ãƒªãƒãƒ¼ãƒ 
ALTER TABLE users RENAME COLUMN password TO password_hash;

-- ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚«ãƒ©ãƒ ã‚’è¿½åŠ ï¼ˆä¸€æ™‚çš„ã«NULLè¨±å¯ï¼‰
ALTER TABLE users ADD COLUMN status VARCHAR(20);

-- æ—¢å­˜ãƒ‡ãƒ¼ã‚¿ã®ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚’è¨­å®š
UPDATE users SET status = CASE
    WHEN is_active = true THEN 'active'
    WHEN is_active = false THEN 'inactive'
    ELSE 'active'
END;

-- statusã‚’NOT NULLã«å¤‰æ›´ã—ã¦ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã‚’è¨­å®š
ALTER TABLE users ALTER COLUMN status SET NOT NULL;
ALTER TABLE users ALTER COLUMN status SET DEFAULT 'active';

-- is_activeã‚«ãƒ©ãƒ ã‚’å‰Šé™¤
ALTER TABLE users DROP COLUMN is_active;

-- CHECKåˆ¶ç´„ã‚’è¿½åŠ 
ALTER TABLE users ADD CONSTRAINT users_status_check
    CHECK (status IN ('active', 'inactive', 'suspended'));

-- ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’è¿½åŠ 
CREATE INDEX idx_users_status ON users(status);
CREATE INDEX idx_users_department ON users(department);
```

**ãƒ•ã‚¡ã‚¤ãƒ«: `backend/migrations/000002_update_users_table.down.sql`**

```sql
-- ãƒ­ãƒ¼ãƒ«ãƒãƒƒã‚¯ç”¨
DROP INDEX IF EXISTS idx_users_department;
DROP INDEX IF EXISTS idx_users_status;
ALTER TABLE users DROP CONSTRAINT IF EXISTS users_status_check;
ALTER TABLE users ADD COLUMN is_active BOOLEAN DEFAULT true;
UPDATE users SET is_active = CASE WHEN status = 'active' THEN true ELSE false END;
ALTER TABLE users DROP COLUMN status;
ALTER TABLE users RENAME COLUMN password_hash TO password;
ALTER TABLE users DROP COLUMN last_login;
ALTER TABLE users DROP COLUMN department;
ALTER TABLE users DROP COLUMN full_name;
```

#### 1-2. ãƒã‚¤ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³å®Ÿè¡Œ

```bash
# ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ï¼ˆå¿µã®ãŸã‚ï¼‰
docker-compose exec postgres pg_dump -U postgres effisio_dev > backup_before_migration.sql

# ãƒã‚¤ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³å®Ÿè¡Œ
make migrate-up

# çµæœç¢ºèª
docker-compose exec postgres psql -U postgres -d effisio_dev -c "\d users"

# æœŸå¾…ã•ã‚Œã‚‹å‡ºåŠ›: full_name, department, password_hash, status, last_login ãŒå­˜åœ¨ã™ã‚‹
```

#### 1-3. ã‚·ãƒ¼ãƒ‰ãƒ‡ãƒ¼ã‚¿ã®æ›´æ–°

**ãƒ•ã‚¡ã‚¤ãƒ«: `backend/scripts/seed.sh`**

```bash
#!/bin/bash

set -e

DB_HOST=${DB_HOST:-localhost}
DB_PORT=${DB_PORT:-5432}
DB_USER=${DB_USER:-postgres}
DB_PASSWORD=${DB_PASSWORD:-postgres}
DB_NAME=${DB_NAME:-effisio_dev}

echo "ğŸŒ± ã‚·ãƒ¼ãƒ‰ãƒ‡ãƒ¼ã‚¿ã‚’æŠ•å…¥ã—ã¦ã„ã¾ã™..."

PGPASSWORD=$DB_PASSWORD psql -h $DB_HOST -p $DB_PORT -U $DB_USER -d $DB_NAME <<EOF

DELETE FROM users WHERE username IN ('admin', 'manager', 'testuser', 'viewer', 'suspended_user');

INSERT INTO users (username, email, full_name, department, password_hash, role, status, created_at, updated_at)
VALUES
  ('admin', 'admin@example.com', 'ç®¡ç†è€… å¤ªéƒ', 'ITéƒ¨',
   '\$2a\$10\$X8yI6qZvKZH5mP3nR4tVH.YqJ5mN6oP7qR8sT9uV0wX1yZ2aB3cD4',
   'admin', 'active', NOW(), NOW()),
  ('manager', 'manager@example.com', 'ç®¡ç† æ¬¡éƒ', 'å–¶æ¥­éƒ¨',
   '\$2a\$10\$Y9zJ7rAvLAI6nQ4oS5uWI.ZrK6nO7pQ8rS9tU0vW1xY2zA3bC4dE5',
   'manager', 'active', NOW(), NOW()),
  ('testuser', 'testuser@example.com', 'ãƒ†ã‚¹ãƒˆ ä¸‰éƒ', 'é–‹ç™ºéƒ¨',
   '\$2a\$10\$Z0aK8sBwMBJ7oR5pT6vXJ.AsL7oP8qR9sT0uV1wX2yZ3aB4cD5eF6',
   'user', 'active', NOW(), NOW()),
  ('viewer', 'viewer@example.com', 'é–²è¦§ å››éƒ', 'ç·å‹™éƒ¨',
   '\$2a\$10\$A1bL9tCxNCK8pS6qU7wYK.BtM8pQ9rS0tU1vW2xY3zA4bC5dD6eG7',
   'viewer', 'active', NOW(), NOW()),
  ('suspended_user', 'suspended@example.com', 'åœæ­¢ äº”éƒ', 'ãªã—',
   '\$2a\$10\$B2cM0uDyODL9qT7rV8xZL.CuN9qR0sT1uV2wX3yZ4aB5cD6eE7fH8',
   'user', 'suspended', NOW(), NOW());

EOF

echo "âœ… ã‚·ãƒ¼ãƒ‰ãƒ‡ãƒ¼ã‚¿ã®æŠ•å…¥ãŒå®Œäº†ã—ã¾ã—ãŸ"
```

```bash
# ã‚·ãƒ¼ãƒ‰ãƒ‡ãƒ¼ã‚¿ã‚’æŠ•å…¥
make seed

# çµæœç¢ºèª
docker-compose exec postgres psql -U postgres -d effisio_dev -c "SELECT id, username, full_name, department, status FROM users;"
```

**âœ… Checkpoint:** ã‚¹ã‚­ãƒ¼ãƒãŒæ›´æ–°ã•ã‚Œã€æ–°ã—ã„ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ãŒè¿½åŠ ã•ã‚Œã¦ã„ã‚‹

---

### Step 2: ãƒ¢ãƒ‡ãƒ«å±¤ã®æ›´æ–°

**ç›®çš„:** Goã®ãƒ¢ãƒ‡ãƒ«å®šç¾©ã‚’æ–°ã—ã„ã‚¹ã‚­ãƒ¼ãƒã«å¯¾å¿œã•ã›ã‚‹

#### 2-1. Userãƒ¢ãƒ‡ãƒ«ã®æ›´æ–°

**ãƒ•ã‚¡ã‚¤ãƒ«: `backend/internal/model/user.go`**

```go
package model

import (
	"time"
	"gorm.io/gorm"
)

// User ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ¢ãƒ‡ãƒ«
type User struct {
	ID           uint           `gorm:"primarykey" json:"id"`
	Username     string         `gorm:"uniqueIndex;not null;size:50" json:"username"`
	Email        string         `gorm:"uniqueIndex;not null;size:255" json:"email"`
	FullName     string         `gorm:"size:100" json:"full_name"`
	Department   string         `gorm:"size:100" json:"department"`
	PasswordHash string         `gorm:"not null;size:255;column:password_hash" json:"-"`
	Role         string         `gorm:"not null;size:20;default:'user'" json:"role"`
	Status       string         `gorm:"not null;size:20;default:'active'" json:"status"`
	LastLogin    *time.Time     `json:"last_login"`
	CreatedAt    time.Time      `json:"created_at"`
	UpdatedAt    time.Time      `json:"updated_at"`
	DeletedAt    gorm.DeletedAt `gorm:"index" json:"-"`
}

// TableName ãƒ†ãƒ¼ãƒ–ãƒ«åã‚’æŒ‡å®š
func (User) TableName() string {
	return "users"
}

// ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹å®šæ•°
const (
	UserStatusActive    = "active"
	UserStatusInactive  = "inactive"
	UserStatusSuspended = "suspended"
)

// ãƒ­ãƒ¼ãƒ«å®šæ•°
const (
	RoleAdmin   = "admin"
	RoleManager = "manager"
	RoleUser    = "user"
	RoleViewer  = "viewer"
)

// UserResponse APIãƒ¬ã‚¹ãƒãƒ³ã‚¹ç”¨
type UserResponse struct {
	ID         uint       `json:"id"`
	Username   string     `json:"username"`
	Email      string     `json:"email"`
	FullName   string     `json:"full_name"`
	Department string     `json:"department"`
	Role       string     `json:"role"`
	Status     string     `json:"status"`
	LastLogin  *time.Time `json:"last_login"`
	CreatedAt  time.Time  `json:"created_at"`
	UpdatedAt  time.Time  `json:"updated_at"`
}

// ToResponse Userã‹ã‚‰UserResponseã¸å¤‰æ›
func (u *User) ToResponse() *UserResponse {
	return &UserResponse{
		ID:         u.ID,
		Username:   u.Username,
		Email:      u.Email,
		FullName:   u.FullName,
		Department: u.Department,
		Role:       u.Role,
		Status:     u.Status,
		LastLogin:  u.LastLogin,
		CreatedAt:  u.CreatedAt,
		UpdatedAt:  u.UpdatedAt,
	}
}

// CreateUserRequest ãƒ¦ãƒ¼ã‚¶ãƒ¼ä½œæˆãƒªã‚¯ã‚¨ã‚¹ãƒˆ
type CreateUserRequest struct {
	Username   string `json:"username" binding:"required,min=3,max=50,alphanum"`
	Email      string `json:"email" binding:"required,email"`
	FullName   string `json:"full_name" binding:"max=100"`
	Department string `json:"department" binding:"max=100"`
	Password   string `json:"password" binding:"required,min=8,max=72"`
	Role       string `json:"role" binding:"required,oneof=admin manager user viewer"`
}

// UpdateUserRequest ãƒ¦ãƒ¼ã‚¶ãƒ¼æ›´æ–°ãƒªã‚¯ã‚¨ã‚¹ãƒˆ
type UpdateUserRequest struct {
	Email      *string `json:"email" binding:"omitempty,email"`
	FullName   *string `json:"full_name" binding:"omitempty,max=100"`
	Department *string `json:"department" binding:"omitempty,max=100"`
	Role       *string `json:"role" binding:"omitempty,oneof=admin manager user viewer"`
	Status     *string `json:"status" binding:"omitempty,oneof=active inactive suspended"`
}

// IsValidStatus ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã®å¦¥å½“æ€§ãƒã‚§ãƒƒã‚¯
func IsValidStatus(status string) bool {
	return status == UserStatusActive || status == UserStatusInactive || status == UserStatusSuspended
}

// IsValidRole ãƒ­ãƒ¼ãƒ«ã®å¦¥å½“æ€§ãƒã‚§ãƒƒã‚¯
func IsValidRole(role string) bool {
	return role == RoleAdmin || role == RoleManager || role == RoleUser || role == RoleViewer
}
```

#### 2-2. ãƒ“ãƒ«ãƒ‰ç¢ºèª

```bash
cd backend
go mod tidy
go build -o bin/server cmd/server/main.go

# ã‚¨ãƒ©ãƒ¼ãŒãªã„ã“ã¨ã‚’ç¢ºèª
```

**âœ… Checkpoint:** ãƒ¢ãƒ‡ãƒ«ãŒæ›´æ–°ã•ã‚Œã€ãƒ“ãƒ«ãƒ‰ã‚¨ãƒ©ãƒ¼ãŒãªã„

---

### Step 3: ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£é–¢æ•°ã®å®Ÿè£…

**ç›®çš„:** çµ±ä¸€ã•ã‚ŒãŸãƒ¬ã‚¹ãƒãƒ³ã‚¹å½¢å¼ã€ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ã€ãƒšãƒ¼ã‚¸ãƒãƒ¼ã‚·ãƒ§ãƒ³ã‚’å®Ÿè£…

#### 3-1. ã‚¨ãƒ©ãƒ¼å®šç¾©

**ãƒ•ã‚¡ã‚¤ãƒ«: `backend/pkg/util/error.go`**

```go
package util

import (
	"fmt"
	"net/http"
)

// ã‚¨ãƒ©ãƒ¼ã‚³ãƒ¼ãƒ‰å®šæ•°
const (
	// èªè¨¼ã‚¨ãƒ©ãƒ¼ (AUTH_xxx)
	ErrCodeUnauthorized      = "AUTH_001"
	ErrCodeInvalidToken      = "AUTH_002"
	ErrCodeTokenExpired      = "AUTH_003"
	ErrCodeInsufficientPermission = "AUTH_004"

	// ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚¨ãƒ©ãƒ¼ (USER_xxx)
	ErrCodeUserNotFound      = "USER_001"
	ErrCodeUserAlreadyExists = "USER_002"
	ErrCodeInvalidCredentials = "USER_003"

	// ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ã‚¨ãƒ©ãƒ¼ (VAL_xxx)
	ErrCodeValidationError   = "VAL_001"
	ErrCodeInvalidParameter  = "VAL_002"

	// ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã‚¨ãƒ©ãƒ¼ (DB_xxx)
	ErrCodeDatabaseError     = "DB_001"
	ErrCodeRecordNotFound    = "DB_002"

	// ã‚·ã‚¹ãƒ†ãƒ ã‚¨ãƒ©ãƒ¼ (SYS_xxx)
	ErrCodeInternalError     = "SYS_001"
	ErrCodePasswordHashError = "SYS_002"
)

// AppError ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã‚¨ãƒ©ãƒ¼
type AppError struct {
	Code       string `json:"code"`
	Message    string `json:"message"`
	StatusCode int    `json:"-"`
	Err        error  `json:"-"`
}

func (e *AppError) Error() string {
	if e.Err != nil {
		return fmt.Sprintf("%s: %s (%v)", e.Code, e.Message, e.Err)
	}
	return fmt.Sprintf("%s: %s", e.Code, e.Message)
}

// ã‚¨ãƒ©ãƒ¼ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
func NewBadRequestError(code string, err error) *AppError {
	return &AppError{Code: code, Message: "Bad request", StatusCode: http.StatusBadRequest, Err: err}
}

func NewUnauthorizedError(code string, err error) *AppError {
	return &AppError{Code: code, Message: "Unauthorized", StatusCode: http.StatusUnauthorized, Err: err}
}

func NewForbiddenError(code string, err error) *AppError {
	return &AppError{Code: code, Message: "Forbidden", StatusCode: http.StatusForbidden, Err: err}
}

func NewNotFoundError(code string, err error) *AppError {
	return &AppError{Code: code, Message: "Resource not found", StatusCode: http.StatusNotFound, Err: err}
}

func NewConflictError(code string, err error) *AppError {
	return &AppError{Code: code, Message: "Resource conflict", StatusCode: http.StatusConflict, Err: err}
}

func NewInternalError(code string, err error) *AppError {
	return &AppError{Code: code, Message: "Internal server error", StatusCode: http.StatusInternalServerError, Err: err}
}
```

#### 3-2. ãƒ¬ã‚¹ãƒãƒ³ã‚¹ãƒ˜ãƒ«ãƒ‘ãƒ¼

**ãƒ•ã‚¡ã‚¤ãƒ«: `backend/pkg/util/response.go`**

```go
package util

import (
	"net/http"
	"github.com/gin-gonic/gin"
	"github.com/go-playground/validator/v10"
)

// çµ±ä¸€ãƒ¬ã‚¹ãƒãƒ³ã‚¹å½¢å¼
type Response struct {
	Code    int         `json:"code"`
	Message string      `json:"message"`
	Data    interface{} `json:"data,omitempty"`
	Error   *ErrorDetail `json:"error,omitempty"`
}

type ErrorDetail struct {
	Code    string      `json:"code"`
	Message string      `json:"message"`
	Details interface{} `json:"details,omitempty"`
}

// Success æˆåŠŸãƒ¬ã‚¹ãƒãƒ³ã‚¹ (200 OK)
func Success(c *gin.Context, data interface{}) {
	c.JSON(http.StatusOK, Response{
		Code:    http.StatusOK,
		Message: "success",
		Data:    data,
	})
}

// Created ä½œæˆæˆåŠŸãƒ¬ã‚¹ãƒãƒ³ã‚¹ (201 Created)
func Created(c *gin.Context, data interface{}) {
	c.JSON(http.StatusCreated, Response{
		Code:    http.StatusCreated,
		Message: "created",
		Data:    data,
	})
}

// NoContent å†…å®¹ãªã— (204 No Content)
func NoContent(c *gin.Context) {
	c.Status(http.StatusNoContent)
}

// Error ã‚¨ãƒ©ãƒ¼ãƒ¬ã‚¹ãƒãƒ³ã‚¹
func Error(c *gin.Context, statusCode int, code string, message string, details interface{}) {
	c.JSON(statusCode, Response{
		Code:    statusCode,
		Message: "error",
		Error: &ErrorDetail{
			Code:    code,
			Message: message,
			Details: details,
		},
	})
}

// ValidationError ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ã‚¨ãƒ©ãƒ¼
func ValidationError(c *gin.Context, errors map[string]string) {
	Error(c, http.StatusBadRequest, ErrCodeValidationError, "Validation failed", errors)
}

// HandleError AppErrorã‹ã‚‰ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã‚’ç”Ÿæˆ
func HandleError(c *gin.Context, err error) {
	if appErr, ok := err.(*AppError); ok {
		Error(c, appErr.StatusCode, appErr.Code, appErr.Message, nil)
	} else {
		Error(c, http.StatusInternalServerError, ErrCodeInternalError, "Internal server error", nil)
	}
}

// ParseValidationErrors ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ã‚¨ãƒ©ãƒ¼ã‚’ãƒ‘ãƒ¼ã‚¹
func ParseValidationErrors(err error) map[string]string {
	errors := make(map[string]string)
	if validationErrors, ok := err.(validator.ValidationErrors); ok {
		for _, e := range validationErrors {
			field := e.Field()
			tag := e.Tag()
			errors[field] = fmt.Sprintf("validation failed on tag '%s'", tag)
		}
	}
	return errors
}
```

#### 3-3. ãƒšãƒ¼ã‚¸ãƒãƒ¼ã‚·ãƒ§ãƒ³

**ãƒ•ã‚¡ã‚¤ãƒ«: `backend/pkg/util/pagination.go`**

```go
package util

import (
	"math"
	"strconv"
	"github.com/gin-gonic/gin"
)

// PaginationParams ãƒšãƒ¼ã‚¸ãƒãƒ¼ã‚·ãƒ§ãƒ³ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿
type PaginationParams struct {
	Page    int `json:"page"`
	PerPage int `json:"per_page"`
	Offset  int `json:"-"`
}

// PaginationInfo ãƒšãƒ¼ã‚¸ãƒãƒ¼ã‚·ãƒ§ãƒ³æƒ…å ±
type PaginationInfo struct {
	Page       int   `json:"page"`
	PerPage    int   `json:"per_page"`
	Total      int64 `json:"total"`
	TotalPages int   `json:"total_pages"`
}

// PaginatedResponse ãƒšãƒ¼ã‚¸ãƒãƒ¼ã‚·ãƒ§ãƒ³ä»˜ããƒ¬ã‚¹ãƒãƒ³ã‚¹
type PaginatedResponse struct {
	Data       interface{}    `json:"data"`
	Pagination PaginationInfo `json:"pagination"`
}

// GetPaginationParams ãƒªã‚¯ã‚¨ã‚¹ãƒˆã‹ã‚‰ãƒšãƒ¼ã‚¸ãƒãƒ¼ã‚·ãƒ§ãƒ³ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’å–å¾—
func GetPaginationParams(c *gin.Context) *PaginationParams {
	page, _ := strconv.Atoi(c.DefaultQuery("page", "1"))
	perPage, _ := strconv.Atoi(c.DefaultQuery("per_page", "10"))

	if page < 1 {
		page = 1
	}
	if perPage < 1 || perPage > 100 {
		perPage = 10
	}

	return &PaginationParams{
		Page:    page,
		PerPage: perPage,
		Offset:  (page - 1) * perPage,
	}
}

// NewPaginationInfo ãƒšãƒ¼ã‚¸ãƒãƒ¼ã‚·ãƒ§ãƒ³æƒ…å ±ã‚’ç”Ÿæˆ
func NewPaginationInfo(total int64, params *PaginationParams) *PaginationInfo {
	totalPages := int(math.Ceil(float64(total) / float64(params.PerPage)))
	return &PaginationInfo{
		Page:       params.Page,
		PerPage:    params.PerPage,
		Total:      total,
		TotalPages: totalPages,
	}
}

// NewPaginatedResponse ãƒšãƒ¼ã‚¸ãƒãƒ¼ã‚·ãƒ§ãƒ³ä»˜ããƒ¬ã‚¹ãƒãƒ³ã‚¹ã‚’ç”Ÿæˆ
func NewPaginatedResponse(data interface{}, total int64, params *PaginationParams) *PaginatedResponse {
	return &PaginatedResponse{
		Data:       data,
		Pagination: *NewPaginationInfo(total, params),
	}
}

// Paginated ãƒšãƒ¼ã‚¸ãƒãƒ¼ã‚·ãƒ§ãƒ³ä»˜ããƒ¬ã‚¹ãƒãƒ³ã‚¹ã‚’è¿”ã™
func Paginated(c *gin.Context, response *PaginatedResponse) {
	c.JSON(http.StatusOK, gin.H{
		"code":       http.StatusOK,
		"message":    "success",
		"data":       response.Data,
		"pagination": response.Pagination,
	})
}
```

**âœ… Checkpoint:** ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£é–¢æ•°ãŒå®Ÿè£…ã•ã‚Œã€ãƒ“ãƒ«ãƒ‰ã‚¨ãƒ©ãƒ¼ãŒãªã„

---

### Step 4: ãƒªãƒã‚¸ãƒˆãƒªå±¤ã®å®Œå…¨å®Ÿè£…

**ç›®çš„:** ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹æ“ä½œã‚’å®Œå…¨ã«å®Ÿè£…

**ãƒ•ã‚¡ã‚¤ãƒ«: `backend/internal/repository/user.go`**

```go
package repository

import (
	"context"
	"github.com/varubogu/effisio/backend/internal/model"
	"github.com/varubogu/effisio/backend/pkg/util"
	"gorm.io/gorm"
)

type UserRepository struct {
	db *gorm.DB
}

func NewUserRepository(db *gorm.DB) *UserRepository {
	return &UserRepository{db: db}
}

// FindAll å…¨ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚’å–å¾—ï¼ˆãƒšãƒ¼ã‚¸ãƒãƒ¼ã‚·ãƒ§ãƒ³ä»˜ãï¼‰
func (r *UserRepository) FindAll(ctx context.Context, params *util.PaginationParams) ([]*model.User, int64, error) {
	var users []*model.User
	var total int64

	// ç·ä»¶æ•°ã‚’å–å¾—
	if err := r.db.WithContext(ctx).Model(&model.User{}).Count(&total).Error; err != nil {
		return nil, 0, err
	}

	// ãƒšãƒ¼ã‚¸ãƒãƒ¼ã‚·ãƒ§ãƒ³ä»˜ãã§å–å¾—
	err := r.db.WithContext(ctx).
		Offset(params.Offset).
		Limit(params.PerPage).
		Order("id ASC").
		Find(&users).Error

	return users, total, err
}

// FindByID IDã§ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚’å–å¾—
func (r *UserRepository) FindByID(ctx context.Context, id uint) (*model.User, error) {
	var user model.User
	err := r.db.WithContext(ctx).First(&user, id).Error
	if err != nil {
		return nil, err
	}
	return &user, nil
}

// FindByEmail ãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹ã§ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚’å–å¾—
func (r *UserRepository) FindByEmail(ctx context.Context, email string) (*model.User, error) {
	var user model.User
	err := r.db.WithContext(ctx).Where("email = ?", email).First(&user).Error
	if err != nil {
		return nil, err
	}
	return &user, nil
}

// FindByUsername ãƒ¦ãƒ¼ã‚¶ãƒ¼åã§ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚’å–å¾—
func (r *UserRepository) FindByUsername(ctx context.Context, username string) (*model.User, error) {
	var user model.User
	err := r.db.WithContext(ctx).Where("username = ?", username).First(&user).Error
	if err != nil {
		return nil, err
	}
	return &user, nil
}

// Create ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚’ä½œæˆ
func (r *UserRepository) Create(ctx context.Context, user *model.User) error {
	return r.db.WithContext(ctx).Create(user).Error
}

// Update ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚’æ›´æ–°
func (r *UserRepository) Update(ctx context.Context, user *model.User) error {
	return r.db.WithContext(ctx).Save(user).Error
}

// Delete ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚’å‰Šé™¤ï¼ˆã‚½ãƒ•ãƒˆãƒ‡ãƒªãƒ¼ãƒˆï¼‰
func (r *UserRepository) Delete(ctx context.Context, id uint) error {
	return r.db.WithContext(ctx).Delete(&model.User{}, id).Error
}

// ExistsByEmail ãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹ã®å­˜åœ¨ç¢ºèª
func (r *UserRepository) ExistsByEmail(ctx context.Context, email string) (bool, error) {
	var count int64
	err := r.db.WithContext(ctx).Model(&model.User{}).Where("email = ?", email).Count(&count).Error
	return count > 0, err
}

// ExistsByUsername ãƒ¦ãƒ¼ã‚¶ãƒ¼åã®å­˜åœ¨ç¢ºèª
func (r *UserRepository) ExistsByUsername(ctx context.Context, username string) (bool, error) {
	var count int64
	err := r.db.WithContext(ctx).Model(&model.User{}).Where("username = ?", username).Count(&count).Error
	return count > 0, err
}
```

**âœ… Checkpoint:** ãƒªãƒã‚¸ãƒˆãƒªå±¤ãŒå®Ÿè£…ã•ã‚Œã€ãƒ“ãƒ«ãƒ‰ã‚¨ãƒ©ãƒ¼ãŒãªã„

---

### Step 5: ã‚µãƒ¼ãƒ“ã‚¹å±¤ã®å®Œå…¨å®Ÿè£…

**ç›®çš„:** ãƒ“ã‚¸ãƒã‚¹ãƒ­ã‚¸ãƒƒã‚¯ã‚’å®Ÿè£…

**ãƒ•ã‚¡ã‚¤ãƒ«: `backend/internal/service/user.go`**

```go
package service

import (
	"context"
	"errors"
	"golang.org/x/crypto/bcrypt"
	"go.uber.org/zap"
	"gorm.io/gorm"

	"github.com/varubogu/effisio/backend/internal/model"
	"github.com/varubogu/effisio/backend/internal/repository"
	"github.com/varubogu/effisio/backend/pkg/util"
)

type UserService struct {
	repo   *repository.UserRepository
	logger *zap.Logger
}

func NewUserService(repo *repository.UserRepository, logger *zap.Logger) *UserService {
	return &UserService{
		repo:   repo,
		logger: logger,
	}
}

// List ãƒ¦ãƒ¼ã‚¶ãƒ¼ä¸€è¦§ã‚’å–å¾—
func (s *UserService) List(ctx context.Context, params *util.PaginationParams) (*util.PaginatedResponse, error) {
	users, total, err := s.repo.FindAll(ctx, params)
	if err != nil {
		s.logger.Error("Failed to fetch users", zap.Error(err))
		return nil, util.NewInternalError(util.ErrCodeDatabaseError, err)
	}

	responses := make([]*model.UserResponse, len(users))
	for i, user := range users {
		responses[i] = user.ToResponse()
	}

	return util.NewPaginatedResponse(responses, total, params), nil
}

// GetByID IDã§ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚’å–å¾—
func (s *UserService) GetByID(ctx context.Context, id uint) (*model.UserResponse, error) {
	user, err := s.repo.FindByID(ctx, id)
	if err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return nil, util.NewNotFoundError(util.ErrCodeUserNotFound, err)
		}
		s.logger.Error("Failed to fetch user", zap.Uint("id", id), zap.Error(err))
		return nil, util.NewInternalError(util.ErrCodeDatabaseError, err)
	}

	return user.ToResponse(), nil
}

// Create ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚’ä½œæˆ
func (s *UserService) Create(ctx context.Context, req *model.CreateUserRequest) (*model.UserResponse, error) {
	// ãƒ¦ãƒ¼ã‚¶ãƒ¼åã®é‡è¤‡ãƒã‚§ãƒƒã‚¯
	exists, err := s.repo.ExistsByUsername(ctx, req.Username)
	if err != nil {
		return nil, util.NewInternalError(util.ErrCodeDatabaseError, err)
	}
	if exists {
		return nil, util.NewConflictError(util.ErrCodeUserAlreadyExists, errors.New("username already exists"))
	}

	// ãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹ã®é‡è¤‡ãƒã‚§ãƒƒã‚¯
	exists, err = s.repo.ExistsByEmail(ctx, req.Email)
	if err != nil {
		return nil, util.NewInternalError(util.ErrCodeDatabaseError, err)
	}
	if exists {
		return nil, util.NewConflictError(util.ErrCodeUserAlreadyExists, errors.New("email already exists"))
	}

	// ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã‚’ãƒãƒƒã‚·ãƒ¥åŒ–
	hashedPassword, err := bcrypt.GenerateFromPassword([]byte(req.Password), bcrypt.DefaultCost)
	if err != nil {
		s.logger.Error("Failed to hash password", zap.Error(err))
		return nil, util.NewInternalError(util.ErrCodePasswordHashError, err)
	}

	// ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ¢ãƒ‡ãƒ«ã‚’ä½œæˆ
	user := &model.User{
		Username:     req.Username,
		Email:        req.Email,
		FullName:     req.FullName,
		Department:   req.Department,
		PasswordHash: string(hashedPassword),
		Role:         req.Role,
		Status:       model.UserStatusActive,
	}

	// ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã«ä¿å­˜
	if err := s.repo.Create(ctx, user); err != nil {
		s.logger.Error("Failed to create user", zap.Error(err))
		return nil, util.NewInternalError(util.ErrCodeDatabaseError, err)
	}

	s.logger.Info("User created", zap.Uint("id", user.ID), zap.String("username", user.Username))
	return user.ToResponse(), nil
}

// Update ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚’æ›´æ–°
func (s *UserService) Update(ctx context.Context, id uint, req *model.UpdateUserRequest) (*model.UserResponse, error) {
	// æ—¢å­˜ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚’å–å¾—
	user, err := s.repo.FindByID(ctx, id)
	if err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return nil, util.NewNotFoundError(util.ErrCodeUserNotFound, err)
		}
		return nil, util.NewInternalError(util.ErrCodeDatabaseError, err)
	}

	// æ›´æ–°ãƒ‡ãƒ¼ã‚¿ã‚’é©ç”¨
	if req.Email != nil {
		// ãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹ã®é‡è¤‡ãƒã‚§ãƒƒã‚¯ï¼ˆè‡ªåˆ†ä»¥å¤–ï¼‰
		existingUser, err := s.repo.FindByEmail(ctx, *req.Email)
		if err == nil && existingUser.ID != id {
			return nil, util.NewConflictError(util.ErrCodeUserAlreadyExists, errors.New("email already exists"))
		}
		user.Email = *req.Email
	}
	if req.FullName != nil {
		user.FullName = *req.FullName
	}
	if req.Department != nil {
		user.Department = *req.Department
	}
	if req.Role != nil {
		user.Role = *req.Role
	}
	if req.Status != nil {
		user.Status = *req.Status
	}

	// ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã‚’æ›´æ–°
	if err := s.repo.Update(ctx, user); err != nil {
		s.logger.Error("Failed to update user", zap.Uint("id", id), zap.Error(err))
		return nil, util.NewInternalError(util.ErrCodeDatabaseError, err)
	}

	s.logger.Info("User updated", zap.Uint("id", user.ID))
	return user.ToResponse(), nil
}

// Delete ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚’å‰Šé™¤
func (s *UserService) Delete(ctx context.Context, id uint) error {
	// å­˜åœ¨ç¢ºèª
	_, err := s.repo.FindByID(ctx, id)
	if err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return util.NewNotFoundError(util.ErrCodeUserNotFound, err)
		}
		return util.NewInternalError(util.ErrCodeDatabaseError, err)
	}

	// å‰Šé™¤å®Ÿè¡Œ
	if err := s.repo.Delete(ctx, id); err != nil {
		s.logger.Error("Failed to delete user", zap.Uint("id", id), zap.Error(err))
		return util.NewInternalError(util.ErrCodeDatabaseError, err)
	}

	s.logger.Info("User deleted", zap.Uint("id", id))
	return nil
}
```

**âœ… Checkpoint:** ã‚µãƒ¼ãƒ“ã‚¹å±¤ãŒå®Ÿè£…ã•ã‚Œã€ãƒ“ãƒ«ãƒ‰ã‚¨ãƒ©ãƒ¼ãŒãªã„

---

### Step 6: ãƒãƒ³ãƒ‰ãƒ©ãƒ¼å±¤ã®å®Œå…¨å®Ÿè£…

**ç›®çš„:** HTTP APIã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆã‚’å®Ÿè£…

**ãƒ•ã‚¡ã‚¤ãƒ«: `backend/internal/handler/user.go`**

```go
package handler

import (
	"strconv"
	"github.com/gin-gonic/gin"
	"go.uber.org/zap"

	"github.com/varubogu/effisio/backend/internal/model"
	"github.com/varubogu/effisio/backend/internal/service"
	"github.com/varubogu/effisio/backend/pkg/util"
)

type UserHandler struct {
	service *service.UserService
	logger  *zap.Logger
}

func NewUserHandler(service *service.UserService, logger *zap.Logger) *UserHandler {
	return &UserHandler{
		service: service,
		logger:  logger,
	}
}

// List ãƒ¦ãƒ¼ã‚¶ãƒ¼ä¸€è¦§ã‚’å–å¾—
// @Summary ãƒ¦ãƒ¼ã‚¶ãƒ¼ä¸€è¦§å–å¾—
// @Tags users
// @Accept json
// @Produce json
// @Param page query int false "ãƒšãƒ¼ã‚¸ç•ªå·" default(1)
// @Param per_page query int false "1ãƒšãƒ¼ã‚¸ã‚ãŸã‚Šã®ä»¶æ•°" default(10)
// @Success 200 {object} util.PaginatedResponse
// @Router /api/v1/users [get]
func (h *UserHandler) List(c *gin.Context) {
	params := util.GetPaginationParams(c)
	result, err := h.service.List(c.Request.Context(), params)
	if err != nil {
		util.HandleError(c, err)
		return
	}

	util.Paginated(c, result)
}

// GetByID IDã§ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚’å–å¾—
// @Summary ãƒ¦ãƒ¼ã‚¶ãƒ¼è©³ç´°å–å¾—
// @Tags users
// @Accept json
// @Produce json
// @Param id path int true "ãƒ¦ãƒ¼ã‚¶ãƒ¼ID"
// @Success 200 {object} model.UserResponse
// @Router /api/v1/users/{id} [get]
func (h *UserHandler) GetByID(c *gin.Context) {
	id, err := strconv.ParseUint(c.Param("id"), 10, 32)
	if err != nil {
		util.Error(c, 400, util.ErrCodeInvalidParameter, "Invalid user ID", nil)
		return
	}

	user, err := h.service.GetByID(c.Request.Context(), uint(id))
	if err != nil {
		util.HandleError(c, err)
		return
	}

	util.Success(c, gin.H{"user": user})
}

// Create ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚’ä½œæˆ
// @Summary ãƒ¦ãƒ¼ã‚¶ãƒ¼ä½œæˆ
// @Tags users
// @Accept json
// @Produce json
// @Param request body model.CreateUserRequest true "ãƒ¦ãƒ¼ã‚¶ãƒ¼ä½œæˆãƒªã‚¯ã‚¨ã‚¹ãƒˆ"
// @Success 201 {object} model.UserResponse
// @Router /api/v1/users [post]
func (h *UserHandler) Create(c *gin.Context) {
	var req model.CreateUserRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		util.ValidationError(c, util.ParseValidationErrors(err))
		return
	}

	user, err := h.service.Create(c.Request.Context(), &req)
	if err != nil {
		util.HandleError(c, err)
		return
	}

	util.Created(c, gin.H{"user": user})
}

// Update ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚’æ›´æ–°
// @Summary ãƒ¦ãƒ¼ã‚¶ãƒ¼æ›´æ–°
// @Tags users
// @Accept json
// @Produce json
// @Param id path int true "ãƒ¦ãƒ¼ã‚¶ãƒ¼ID"
// @Param request body model.UpdateUserRequest true "ãƒ¦ãƒ¼ã‚¶ãƒ¼æ›´æ–°ãƒªã‚¯ã‚¨ã‚¹ãƒˆ"
// @Success 200 {object} model.UserResponse
// @Router /api/v1/users/{id} [put]
func (h *UserHandler) Update(c *gin.Context) {
	id, err := strconv.ParseUint(c.Param("id"), 10, 32)
	if err != nil {
		util.Error(c, 400, util.ErrCodeInvalidParameter, "Invalid user ID", nil)
		return
	}

	var req model.UpdateUserRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		util.ValidationError(c, util.ParseValidationErrors(err))
		return
	}

	user, err := h.service.Update(c.Request.Context(), uint(id), &req)
	if err != nil {
		util.HandleError(c, err)
		return
	}

	util.Success(c, gin.H{"user": user})
}

// Delete ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚’å‰Šé™¤
// @Summary ãƒ¦ãƒ¼ã‚¶ãƒ¼å‰Šé™¤
// @Tags users
// @Accept json
// @Produce json
// @Param id path int true "ãƒ¦ãƒ¼ã‚¶ãƒ¼ID"
// @Success 204
// @Router /api/v1/users/{id} [delete]
func (h *UserHandler) Delete(c *gin.Context) {
	id, err := strconv.ParseUint(c.Param("id"), 10, 32)
	if err != nil {
		util.Error(c, 400, util.ErrCodeInvalidParameter, "Invalid user ID", nil)
		return
	}

	if err := h.service.Delete(c.Request.Context(), uint(id)); err != nil {
		util.HandleError(c, err)
		return
	}

	util.NoContent(c)
}
```

#### ãƒ«ãƒ¼ãƒ†ã‚£ãƒ³ã‚°ã®æ›´æ–°

**ãƒ•ã‚¡ã‚¤ãƒ«: `backend/cmd/server/main.go`** ã®ä¸€éƒ¨ã‚’æ›´æ–°

```go
func setupRouter(cfg *config.Config, logger *zap.Logger, healthHandler *handler.HealthHandler, userHandler *handler.UserHandler) *gin.Engine {
	if cfg.Server.Env == "production" {
		gin.SetMode(gin.ReleaseMode)
	}

	r := gin.New()
	r.Use(middleware.Logger(logger))
	r.Use(middleware.Recovery(logger))
	r.Use(middleware.CORS())

	// Health check
	r.GET("/health", healthHandler.Check)

	// API routes
	v1 := r.Group("/api/v1")
	{
		v1.GET("/ping", func(c *gin.Context) {
			c.JSON(200, gin.H{"message": "pong"})
		})

		users := v1.Group("/users")
		{
			users.GET("", userHandler.List)
			users.GET("/:id", userHandler.GetByID)
			users.POST("", userHandler.Create)
			users.PUT("/:id", userHandler.Update)
			users.DELETE("/:id", userHandler.Delete)
		}
	}

	return r
}
```

#### ãƒ“ãƒ«ãƒ‰ã¨ãƒ†ã‚¹ãƒˆ

```bash
cd backend

# ãƒ“ãƒ«ãƒ‰
go mod tidy
make build

# èµ·å‹•
docker-compose restart backend

# ãƒ­ã‚°ç¢ºèª
docker-compose logs -f backend

# APIãƒ†ã‚¹ãƒˆ
curl http://localhost:8080/api/v1/ping
curl http://localhost:8080/api/v1/users | jq
```

**âœ… Checkpoint:** ãƒãƒ³ãƒ‰ãƒ©ãƒ¼å±¤ãŒå®Ÿè£…ã•ã‚Œã€APIãŒå‹•ä½œã™ã‚‹

---

### Step 7: ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ãƒ†ã‚¹ãƒˆã®å®Ÿè£…

**ç›®çš„:** å˜ä½“ãƒ†ã‚¹ãƒˆã‚’å®Ÿè£…ã—ã¦ã‚«ãƒãƒ¬ãƒƒã‚¸70%ä»¥ä¸Šã‚’é”æˆ

#### 7-1. ãƒªãƒã‚¸ãƒˆãƒªãƒ†ã‚¹ãƒˆ

**ãƒ•ã‚¡ã‚¤ãƒ«: `backend/internal/repository/user_test.go`**

```go
package repository

import (
	"context"
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"gorm.io/driver/sqlite"
	"gorm.io/gorm"

	"github.com/varubogu/effisio/backend/internal/model"
	"github.com/varubogu/effisio/backend/pkg/util"
)

func setupTestDB(t *testing.T) *gorm.DB {
	db, err := gorm.Open(sqlite.Open(":memory:"), &gorm.Config{})
	require.NoError(t, err)

	err = db.AutoMigrate(&model.User{})
	require.NoError(t, err)

	return db
}

func TestUserRepository_Create(t *testing.T) {
	db := setupTestDB(t)
	repo := NewUserRepository(db)

	user := &model.User{
		Username:     "testuser",
		Email:        "test@example.com",
		PasswordHash: "hashed",
		Role:         model.RoleUser,
		Status:       model.UserStatusActive,
	}

	err := repo.Create(context.Background(), user)
	assert.NoError(t, err)
	assert.NotZero(t, user.ID)
}

func TestUserRepository_FindByID(t *testing.T) {
	db := setupTestDB(t)
	repo := NewUserRepository(db)

	// ãƒ†ã‚¹ãƒˆãƒ‡ãƒ¼ã‚¿ä½œæˆ
	user := &model.User{
		Username:     "testuser",
		Email:        "test@example.com",
		PasswordHash: "hashed",
		Role:         model.RoleUser,
		Status:       model.UserStatusActive,
	}
	repo.Create(context.Background(), user)

	// å–å¾—ãƒ†ã‚¹ãƒˆ
	found, err := repo.FindByID(context.Background(), user.ID)
	assert.NoError(t, err)
	assert.Equal(t, user.Username, found.Username)
}

func TestUserRepository_FindAll(t *testing.T) {
	db := setupTestDB(t)
	repo := NewUserRepository(db)

	// ãƒ†ã‚¹ãƒˆãƒ‡ãƒ¼ã‚¿ä½œæˆ
	users := []*model.User{
		{Username: "user1", Email: "user1@example.com", PasswordHash: "hash", Role: model.RoleUser, Status: model.UserStatusActive},
		{Username: "user2", Email: "user2@example.com", PasswordHash: "hash", Role: model.RoleUser, Status: model.UserStatusActive},
		{Username: "user3", Email: "user3@example.com", PasswordHash: "hash", Role: model.RoleUser, Status: model.UserStatusActive},
	}
	for _, u := range users {
		repo.Create(context.Background(), u)
	}

	// ãƒšãƒ¼ã‚¸ãƒãƒ¼ã‚·ãƒ§ãƒ³ä»˜ãå–å¾—
	params := &util.PaginationParams{Page: 1, PerPage: 10, Offset: 0}
	result, total, err := repo.FindAll(context.Background(), params)

	assert.NoError(t, err)
	assert.Equal(t, int64(3), total)
	assert.Len(t, result, 3)
}

func TestUserRepository_Update(t *testing.T) {
	db := setupTestDB(t)
	repo := NewUserRepository(db)

	// ãƒ†ã‚¹ãƒˆãƒ‡ãƒ¼ã‚¿ä½œæˆ
	user := &model.User{
		Username:     "testuser",
		Email:        "test@example.com",
		PasswordHash: "hashed",
		Role:         model.RoleUser,
		Status:       model.UserStatusActive,
	}
	repo.Create(context.Background(), user)

	// æ›´æ–°
	user.Email = "updated@example.com"
	err := repo.Update(context.Background(), user)
	assert.NoError(t, err)

	// ç¢ºèª
	updated, _ := repo.FindByID(context.Background(), user.ID)
	assert.Equal(t, "updated@example.com", updated.Email)
}

func TestUserRepository_Delete(t *testing.T) {
	db := setupTestDB(t)
	repo := NewUserRepository(db)

	// ãƒ†ã‚¹ãƒˆãƒ‡ãƒ¼ã‚¿ä½œæˆ
	user := &model.User{
		Username:     "testuser",
		Email:        "test@example.com",
		PasswordHash: "hashed",
		Role:         model.RoleUser,
		Status:       model.UserStatusActive,
	}
	repo.Create(context.Background(), user)

	// å‰Šé™¤
	err := repo.Delete(context.Background(), user.ID)
	assert.NoError(t, err)

	// ç¢ºèªï¼ˆã‚½ãƒ•ãƒˆãƒ‡ãƒªãƒ¼ãƒˆãªã®ã§ Unscoped ãŒå¿…è¦ï¼‰
	var deleted model.User
	result := db.Unscoped().First(&deleted, user.ID)
	assert.NoError(t, result.Error)
	assert.NotNil(t, deleted.DeletedAt)
}
```

#### 7-2. ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ

```bash
cd backend

# ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ
go test ./... -v

# ã‚«ãƒãƒ¬ãƒƒã‚¸ä»˜ã
go test ./... -coverprofile=coverage.out
go tool cover -html=coverage.out -o coverage.html

# ã‚«ãƒãƒ¬ãƒƒã‚¸ç¢ºèª
open coverage.html
```

**âœ… Checkpoint:** ãƒ†ã‚¹ãƒˆãŒå®Ÿè£…ã•ã‚Œã€ã‚«ãƒãƒ¬ãƒƒã‚¸ãŒ70%ä»¥ä¸Š

---

### Step 8: ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰ã®æ›´æ–°

**ç›®çš„:** ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰ã‚’æ–°ã—ã„APIãƒ¬ã‚¹ãƒãƒ³ã‚¹å½¢å¼ã«å¯¾å¿œã•ã›ã‚‹

#### 8-1. å‹å®šç¾©ã®æ›´æ–°

**ãƒ•ã‚¡ã‚¤ãƒ«: `frontend/src/types/user.ts`**

```typescript
export interface User {
  id: number;
  username: string;
  email: string;
  full_name: string;
  department: string;
  role: 'admin' | 'manager' | 'user' | 'viewer';
  status: 'active' | 'inactive' | 'suspended';
  last_login: string | null;
  created_at: string;
  updated_at: string;
}

export interface CreateUserRequest {
  username: string;
  email: string;
  full_name?: string;
  department?: string;
  password: string;
  role: 'admin' | 'manager' | 'user' | 'viewer';
}

export interface UpdateUserRequest {
  email?: string;
  full_name?: string;
  department?: string;
  role?: 'admin' | 'manager' | 'user' | 'viewer';
  status?: 'active' | 'inactive' | 'suspended';
}

export interface PaginatedResponse<T> {
  code: number;
  message: string;
  data: T[];
  pagination: {
    page: number;
    per_page: number;
    total: number;
    total_pages: number;
  };
}

export interface ApiResponse<T> {
  code: number;
  message: string;
  data: T;
}

export type UserStatus = 'active' | 'inactive' | 'suspended';
export type UserRole = 'admin' | 'manager' | 'user' | 'viewer';
```

#### 8-2. APIé–¢æ•°ã®æ›´æ–°

**ãƒ•ã‚¡ã‚¤ãƒ«: `frontend/src/lib/users.ts`**

```typescript
import { api } from './api';
import type {
  User,
  CreateUserRequest,
  UpdateUserRequest,
  PaginatedResponse,
  ApiResponse,
} from '@/types/user';

export const usersApi = {
  async getUsers(page = 1, perPage = 10): Promise<PaginatedResponse<User>> {
    const response = await api.get<PaginatedResponse<User>>('/users', {
      params: { page, per_page: perPage },
    });
    return response.data;
  },

  async getUserById(id: number): Promise<User> {
    const response = await api.get<ApiResponse<{ user: User }>>(`/users/${id}`);
    return response.data.data.user;
  },

  async createUser(data: CreateUserRequest): Promise<User> {
    const response = await api.post<ApiResponse<{ user: User }>>('/users', data);
    return response.data.data.user;
  },

  async updateUser(id: number, data: UpdateUserRequest): Promise<User> {
    const response = await api.put<ApiResponse<{ user: User }>>(`/users/${id}`, data);
    return response.data.data.user;
  },

  async deleteUser(id: number): Promise<void> {
    await api.delete(`/users/${id}`);
  },
};
```

#### 8-3. ã‚«ã‚¹ã‚¿ãƒ ãƒ•ãƒƒã‚¯ã®æ›´æ–°

**ãƒ•ã‚¡ã‚¤ãƒ«: `frontend/src/hooks/useUsers.ts`**

```typescript
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { usersApi } from '@/lib/users';
import type { CreateUserRequest, UpdateUserRequest } from '@/types/user';

export function useUsers(page = 1, perPage = 10) {
  return useQuery({
    queryKey: ['users', page, perPage],
    queryFn: () => usersApi.getUsers(page, perPage),
  });
}

export function useUser(id: number) {
  return useQuery({
    queryKey: ['users', id],
    queryFn: () => usersApi.getUserById(id),
    enabled: !!id,
  });
}

export function useCreateUser() {
  const queryClient = useQueryClient();
  return useMutation({
    mutationFn: (data: CreateUserRequest) => usersApi.createUser(data),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['users'] });
    },
  });
}

export function useUpdateUser() {
  const queryClient = useQueryClient();
  return useMutation({
    mutationFn: ({ id, data }: { id: number; data: UpdateUserRequest }) =>
      usersApi.updateUser(id, data),
    onSuccess: (_, variables) => {
      queryClient.invalidateQueries({ queryKey: ['users'] });
      queryClient.invalidateQueries({ queryKey: ['users', variables.id] });
    },
  });
}

export function useDeleteUser() {
  const queryClient = useQueryClient();
  return useMutation({
    mutationFn: (id: number) => usersApi.deleteUser(id),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['users'] });
    },
  });
}
```

#### 8-4. ãƒ“ãƒ«ãƒ‰ã¨ãƒ†ã‚¹ãƒˆ

```bash
cd frontend

# å‹ãƒã‚§ãƒƒã‚¯
npm run type-check

# ãƒ“ãƒ«ãƒ‰
npm run build

# ãƒ†ã‚¹ãƒˆ
npm test
```

**âœ… Checkpoint:** ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰ãŒæ›´æ–°ã•ã‚Œã€æ–°ã—ã„APIã«å¯¾å¿œã—ã¦ã„ã‚‹

---

### Step 9: çµ±åˆãƒ†ã‚¹ãƒˆ

**ç›®çš„:** å…¨ä½“ãŒæ­£ã—ãå‹•ä½œã™ã‚‹ã“ã¨ã‚’ç¢ºèª

#### 9-1. APIãƒ†ã‚¹ãƒˆ

```bash
# Ping
curl http://localhost:8080/api/v1/ping
# {"message":"pong"}

# ãƒ¦ãƒ¼ã‚¶ãƒ¼ä¸€è¦§ï¼ˆãƒšãƒ¼ã‚¸ãƒãƒ¼ã‚·ãƒ§ãƒ³ä»˜ãï¼‰
curl "http://localhost:8080/api/v1/users?page=1&per_page=10" | jq

# æœŸå¾…ã•ã‚Œã‚‹å‡ºåŠ›:
# {
#   "code": 200,
#   "message": "success",
#   "data": [
#     {
#       "id": 1,
#       "username": "admin",
#       "email": "admin@example.com",
#       "full_name": "ç®¡ç†è€… å¤ªéƒ",
#       "department": "ITéƒ¨",
#       "role": "admin",
#       "status": "active",
#       "last_login": null,
#       ...
#     }
#   ],
#   "pagination": {
#     "page": 1,
#     "per_page": 10,
#     "total": 5,
#     "total_pages": 1
#   }
# }

# ãƒ¦ãƒ¼ã‚¶ãƒ¼è©³ç´°
curl http://localhost:8080/api/v1/users/1 | jq

# ãƒ¦ãƒ¼ã‚¶ãƒ¼ä½œæˆ
curl -X POST http://localhost:8080/api/v1/users \
  -H "Content-Type: application/json" \
  -d '{
    "username": "newuser",
    "email": "newuser@example.com",
    "full_name": "æ–°è¦ ãƒ¦ãƒ¼ã‚¶ãƒ¼",
    "department": "é–‹ç™ºéƒ¨",
    "password": "password123",
    "role": "user"
  }' | jq

# ãƒ¦ãƒ¼ã‚¶ãƒ¼æ›´æ–°
curl -X PUT http://localhost:8080/api/v1/users/6 \
  -H "Content-Type: application/json" \
  -d '{
    "full_name": "æ›´æ–° ãƒ¦ãƒ¼ã‚¶ãƒ¼",
    "status": "inactive"
  }' | jq

# ãƒ¦ãƒ¼ã‚¶ãƒ¼å‰Šé™¤
curl -X DELETE http://localhost:8080/api/v1/users/6
```

#### 9-2. ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰ãƒ†ã‚¹ãƒˆ

```bash
# ãƒ–ãƒ©ã‚¦ã‚¶ã§ç¢ºèª
# http://localhost:3000/users

# æœŸå¾…ã•ã‚Œã‚‹å‹•ä½œ:
# - ãƒ¦ãƒ¼ã‚¶ãƒ¼ä¸€è¦§ãŒè¡¨ç¤ºã•ã‚Œã‚‹
# - ãƒšãƒ¼ã‚¸ãƒãƒ¼ã‚·ãƒ§ãƒ³ãŒå‹•ä½œã™ã‚‹
# - æ–°ã—ã„ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ï¼ˆfull_name, department, statusï¼‰ãŒè¡¨ç¤ºã•ã‚Œã‚‹
```

**âœ… Checkpoint:** å…¨ã¦ã®æ©Ÿèƒ½ãŒæ­£ã—ãå‹•ä½œã™ã‚‹

---

## å®Œäº†ãƒã‚§ãƒƒã‚¯ãƒªã‚¹ãƒˆ

Phase 1ã®å®Ÿè£…ãŒå®Œäº†ã—ãŸã“ã¨ã‚’ç¢ºèªã—ã¦ãã ã•ã„:

### ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰

- [ ] ã‚¹ã‚­ãƒ¼ãƒãŒè¨­è¨ˆä»•æ§˜ã«æº–æ‹ ã—ã¦ã„ã‚‹ï¼ˆfull_name, department, password_hash, status, last_loginï¼‰
- [ ] ãƒã‚¤ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ãŒæ­£å¸¸ã«å®Ÿè¡Œã•ã‚Œã‚‹
- [ ] ã‚·ãƒ¼ãƒ‰ãƒ‡ãƒ¼ã‚¿ãŒæŠ•å…¥ã•ã‚Œã‚‹
- [ ] ãƒ¢ãƒ‡ãƒ«å±¤ãŒæ›´æ–°ã•ã‚Œã¦ã„ã‚‹
- [ ] ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£é–¢æ•°ï¼ˆã‚¨ãƒ©ãƒ¼ã€ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã€ãƒšãƒ¼ã‚¸ãƒãƒ¼ã‚·ãƒ§ãƒ³ï¼‰ãŒå®Ÿè£…ã•ã‚Œã¦ã„ã‚‹
- [ ] ãƒªãƒã‚¸ãƒˆãƒªå±¤ãŒå®Œå…¨ã«å®Ÿè£…ã•ã‚Œã¦ã„ã‚‹
- [ ] ã‚µãƒ¼ãƒ“ã‚¹å±¤ãŒå®Œå…¨ã«å®Ÿè£…ã•ã‚Œã¦ã„ã‚‹ï¼ˆãƒ“ã‚¸ãƒã‚¹ãƒ­ã‚¸ãƒƒã‚¯ã€ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ã€ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ï¼‰
- [ ] ãƒãƒ³ãƒ‰ãƒ©ãƒ¼å±¤ãŒå®Œå…¨ã«å®Ÿè£…ã•ã‚Œã¦ã„ã‚‹
- [ ] ãƒ«ãƒ¼ãƒ†ã‚£ãƒ³ã‚°ãŒæ­£ã—ãè¨­å®šã•ã‚Œã¦ã„ã‚‹
- [ ] å˜ä½“ãƒ†ã‚¹ãƒˆãŒå®Ÿè£…ã•ã‚Œã¦ã„ã‚‹ï¼ˆã‚«ãƒãƒ¬ãƒƒã‚¸70%ä»¥ä¸Šï¼‰
- [ ] `make test` ãŒæˆåŠŸã™ã‚‹
- [ ] `make lint` ãŒæˆåŠŸã™ã‚‹
- [ ] `make build` ãŒæˆåŠŸã™ã‚‹

### API

- [ ] `GET /api/v1/users` ãŒå‹•ä½œã™ã‚‹ï¼ˆãƒšãƒ¼ã‚¸ãƒãƒ¼ã‚·ãƒ§ãƒ³ä»˜ãï¼‰
- [ ] `GET /api/v1/users/:id` ãŒå‹•ä½œã™ã‚‹
- [ ] `POST /api/v1/users` ãŒå‹•ä½œã™ã‚‹ï¼ˆãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³å«ã‚€ï¼‰
- [ ] `PUT /api/v1/users/:id` ãŒå‹•ä½œã™ã‚‹
- [ ] `DELETE /api/v1/users/:id` ãŒå‹•ä½œã™ã‚‹
- [ ] ã‚¨ãƒ©ãƒ¼ãƒ¬ã‚¹ãƒãƒ³ã‚¹ãŒçµ±ä¸€ã•ã‚Œã¦ã„ã‚‹
- [ ] ãƒšãƒ¼ã‚¸ãƒãƒ¼ã‚·ãƒ§ãƒ³æƒ…å ±ãŒæ­£ã—ãè¿”ã•ã‚Œã‚‹

### ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰

- [ ] TypeScriptå‹å®šç¾©ãŒæ›´æ–°ã•ã‚Œã¦ã„ã‚‹
- [ ] APIé–¢æ•°ãŒæ–°ã—ã„ãƒ¬ã‚¹ãƒãƒ³ã‚¹å½¢å¼ã«å¯¾å¿œã—ã¦ã„ã‚‹
- [ ] ã‚«ã‚¹ã‚¿ãƒ ãƒ•ãƒƒã‚¯ãŒå®Ÿè£…ã•ã‚Œã¦ã„ã‚‹
- [ ] ãƒ¦ãƒ¼ã‚¶ãƒ¼ä¸€è¦§ãƒšãƒ¼ã‚¸ãŒå‹•ä½œã™ã‚‹
- [ ] æ–°ã—ã„ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ãŒè¡¨ç¤ºã•ã‚Œã‚‹ï¼ˆfull_name, department, statusï¼‰
- [ ] ãƒšãƒ¼ã‚¸ãƒãƒ¼ã‚·ãƒ§ãƒ³ãŒå‹•ä½œã™ã‚‹
- [ ] `npm run type-check` ãŒæˆåŠŸã™ã‚‹
- [ ] `npm run lint` ãŒæˆåŠŸã™ã‚‹
- [ ] `npm run build` ãŒæˆåŠŸã™ã‚‹
- [ ] `npm test` ãŒæˆåŠŸã™ã‚‹

### ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ

- [ ] CHANGELOG.md ã«å¤‰æ›´å†…å®¹ã‚’è¨˜è¼‰ã—ãŸ
- [ ] ã‚³ãƒ¼ãƒ‰ã«ã‚³ãƒ¡ãƒ³ãƒˆã‚’è¿½åŠ ã—ãŸ
- [ ] å¿…è¦ã«å¿œã˜ã¦README.mdã‚’æ›´æ–°ã—ãŸ

### Git

- [ ] å…¨ã¦ã®å¤‰æ›´ã‚’ã‚³ãƒŸãƒƒãƒˆã—ãŸ
- [ ] æ„å‘³ã®ã‚ã‚‹ã‚³ãƒŸãƒƒãƒˆãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’æ›¸ã„ãŸï¼ˆConventional Commitså½¢å¼ï¼‰
- [ ] ãƒªãƒ¢ãƒ¼ãƒˆã«ãƒ—ãƒƒã‚·ãƒ¥ã—ãŸ
- [ ] Pull Requestã‚’ä½œæˆã—ãŸï¼ˆãƒãƒ¼ãƒ é–‹ç™ºã®å ´åˆï¼‰

---

## æ¬¡ã®ã‚¹ãƒ†ãƒƒãƒ—

Phase 1ãŒå®Œäº†ã—ãŸã‚‰ã€**Phase 2: èªè¨¼ãƒ»èªå¯æ©Ÿèƒ½** ã®å®Ÿè£…ã«é€²ã‚“ã§ãã ã•ã„ã€‚

è©³ç´°ã¯ **[IMPLEMENTATION_PHASES.md](IMPLEMENTATION_PHASES.md)** ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚

---

**æœ€çµ‚æ›´æ–°**: 2025-01-20
